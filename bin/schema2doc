#!/usr/bin/env node

var fs = require('fs');
var byline = require('byline');

// templates
var toCommon = require('../lib/toCommon'); // contains processing of schema
var toCsv = require('../lib/toCsv');
var toHtml = require('../lib/toHtml');
var toRaw = require('../lib/toRaw');

// get arguments and if help is needed end
var args = require('minimist')(process.argv.slice(2));
if (args.h || args.help) {
	printHelp();
	return;
}


// process input stream
var input = [];
var stream = byline(process.stdin/*,{keepEmptyLines:true}*/);
stream.on("data", function (line) {
	input.push(line + "");
}).on("end", function () {
	processInput(input.join("\n"));
});

function processInput(inputString) {
	function generate(/*callback */ renderer, /*string*/ jsonInput, /*string?*/ file) {
		// renderer: function
		//		callback to toCsv, toHtml, toRaw
		// jsonInput : string
		//		input schema that will be processed
		// file : string?
		//		path where output file should be saved
		write(renderer(jsonInput, toCommon), file);
	}

	var columnsMap = {
		rqnn: {
			title: "RQ/NN",
			visible: kernelTrue
		},
		field: {
			title: "Field",
			visible: kernelTrue
		},
		type: { 
			title: "Type",
			visible: kernelTrue 
		},
		format: {
			title: "Format",
			visible: kernelTrue
		},
		constraints: { 
			title: "Constraints", 
			visible: function(options) {
			return options.a;	
		} },
		description: { title: "Desc", visible: kernelTrue }
	};
	function createOptions(args) {
		var columns = {};
		Object.keys(columnsMap).forEach(function(key) {
			columnsMap[key].visible(args) && (columns[key] = columnsMap[key].title);
		});
		
		return {
			columns : columns
		};	
	}
		
	

	try {
		input = JSON.parse(inputString);
	} catch (e) {
		process.stderr.write("ERROR: schema could not be parsed, please check schema\n");
		process.stderr.write(e);
	}

	var filePath = args._[0] || args.o;	
	var options = createOptions(args);

	var rendererMap = {
		c: toCsv,
		l: toHtml,
		r: toRaw
	};

	var rendered = toRaw;
	Object.keys(rendererMap).forEach(function (key) {
		args[key] == true && (rendered = rendererMap[key]);
	});

	generate(rendered(options), input, filePath);
}


function write(/*string*/ str, /*string?*/file) {
	// str : string
	//		processed schema, output depends on options (html, csv, raw)
	// file : string?
	//		if defined, try to save output to given file path, output is always print on stdout
	if (file) {
		try {
			fs.writeFile(file, str);
		} catch (e) {
			process.stderr.write("Error: output could not be saved");
			process.stderr.write(e);
		}
	}
	process.stdout.write(str + "\n");
}

function printHelp() {
	var helpText = "Usage:\n" + //
		"schema2doc [-a|-h|-r|-l|-c|-o <FILE>]\n" + //
		"options:\n" + //
		"\t-a print constraints, only intervals are now supported\n" + //
		"\t-h print this help (alias --help)\n" + //
		"\t-r print to raw format (default)\n" + //
		"\t-l print to html format, table and simple css\n" + //
		"\t-c print to csv format\n" + //
		"\n"
		"\t-o <FILE> save output to a file (file will be created and overwritten)\n";

	console.log(helpText);
}

function kernelTrue(/*options*/) {
	return true;
}
